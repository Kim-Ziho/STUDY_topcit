# 4. 소프트웨어 개발

1. 소프트웨어의 이해
2. 자료구조와 알고리즘
3. 소프트웨어 분석
4. 소프트웨어 설계
5. 소프트웨어 구현 및 테스팅
6. 소프트웨어 관리
7. 소프트웨어 개발 동향

## 4.1. 소프트웨어의 이해

### 4.1.1. 소프트웨어의 이해

#### 소프트웨어의 정의 및 특징

정의

- 컴퓨터 프로그램과 개발 과정에서 생성되는 모든 산출물을 포함하는 용어
- 자료 구조, 데이터베이스 구조, 테스트 결과 등을 포함

소프트웨어의 특징

- 제조가 아닌 개발
  - 개발: 개인의 능력에 따라 시간, 효율성의 차이가 커짐 -> 인재가 소프트웨어의 핵심
  - 제조 : 정해진 틀에 맞춰 일정하게 생산하는 것
- 재사용 가능
- 비가시성 
  - 실체가 보이지 않으므로 개발 진행 상태를 알기 어려움
  - 요구사항을 정의하기 어려움
- 수정과 복제의 용이성
- 높은 유지보수 지용

#### 소프트웨어의 위기

정의

- 시스템의 대규모화, SW 수요 급증으로 소프트웨어의 신뢰성이 저하, 개발비의 증대, 개발 지연 등의 현상이 발생하면서 개발 계획의 수행이 매우 곤란해진 상황

배경

1. SW의 특성, 시스템의 대규모화, 시스템의 복잡화, 빠른 환경 변화
2. SW의 위기 등장
   - 신뢰성 저하
   - 개발비 증대
   - 개발 지연
   - 체계적 관리의 어려움
3. SW의 공학적 접근 필요

### 4.1.2. 소프트웨어 공학의 이해

#### 소프트웨어 공학의 이해

정의

- 소프트웨어의 개발, 운영, 유지보수 등의 생명주기 전반을 체계적, 서술적, 정량적으로 다루는 학문
- 공학의 개념을 소프트웨어에 적용한 학문

4가지 구성요소와 목적

- SW공학의 구성요소
  - 방법 : SW를 구축하기 위해 필요한 기술적인 방법 제공
  - 도구 : 생산성, 일관성을 목적으로 사용하는 방법들을 자동화, 반자동화 시켜놓은 것
  - 사람 : 사람과 조직에 의해 수립, 개선, 유지 등이 이루어지므로 사람에 대한 의존성이 높음
  - 절차 : '방법'과 '도구'를 결합하여 SW의 합리적이고 적시 개발을 가능하게 하는 순서
- SW공학의 목적
  - 고품질의 SW 생산
  - 주어진 비용과

#### 소프트웨어 개발 생명주기

정의

- SDLC : SW Developement Life Cycle
- 사용자 환경 및 문제점 이해에서 운용, 유지 보수에 이르기까지의 모든 과정
- 효과적인 SW개발을 위해 개발 방법론을 모델화한 모형

절차

1. 타당성 검토
2. 개발 계획
3. 요구사항 분석
4. 설계 5. 구현 6. 테스트 7. 운용

5. 유지보수

목적

- 프로젝트 비용 산정과 개발 계획 수립의 기본 골격 구성
- 용어의 표준화
- 문서화가 충실한 프로젝트 관리

모델 선정

- 기업에서 프로젝트의 개발 프로세스를 테일러링하는데 중요한 활동
- 시스템 개발의 리스크와 불확실성 및 이에 대한 이해를 바탕으로 수행
- 선택한 모델은 프로젝트에 존재하는 리스크/불확실성을 최소화시킬 수 있어야 함

SW 생명주기 모델의 종류

1. 폭포수 Waterfall 모델
   - 요구사항 분석, 설계, 개발, 테스트, 유지관리의 프로세스를 순차적으로 수행하는 전통적인 생명주기 모델
   - 대규모 프로젝트의 기술적 위험도가 낮은 경우에 적용 용이함
   - 시스템의 요구사항이 모두 식별되고 명확할 때 사용
   - 프로젝트 관리자와 개발자에게 프로젝트 수행 동안 어떤 활동을 수행해야 하는지 명확히 적달 가능하고 SW개발에 대해 잘 알지 못하는 고객을 이해시키기 용이함
   - 개발 활동의 시작, 종료 조건 및 프로젝트를 효과적으로 관리할 수 있는 척도 등을 명확히 정의 가능
2. V모델
   - 폭포수 모델에서 프로젝트의 검증 및 확인 Verification and Validation을 강조하는 모델
3. 프로토타입 VP, V with Prototype 모델
   - 시스템에 대한 이해 또는 리스크, 불확실성 요소와 같은 이슈를 해결하기 위해 시스템 또는 그 일부를 빠르게 개발 (시제품 개발)하는 방법
   - 폭포수 및 V모델의 개발 단계에 적용 가능하고 독립적인 생명주기 모델로 사용 가능함
   - V모델에 프로토타이핑을 추가함으로써 프로젝트의 불확실성 요소나 리스크를 줄일 수 있음
4. 진화 Evolutionary 모델
   - 핵심 요구사항을 선 개발 후 고객의 피드백에 따라 확대 또는 진화된 형태의 추가적인 요구사항을 분석/구현하며 최종 시스템을 상세화 시켜 나가는 개발 모형
   - 목적 : 시스템 개발 시간 단축, 시스템 명세가 불분명할 경우 SW개발 가능
   - 시스템이 여러 번에 걸쳐 개발되기 때문에 시스템의 예상치 못한 문제 도출 및 조기 수정 가능
5. 증가/점증 Incremental 모델
   - 요구사항을 분할한 뒤 각 분할된 요구사항을 설계/구현하여 완성된 시스템을 개발하는 모형
   - 목적 : 시스템 개발 시간 단축, 핵심 기능 선 개발
   - 시스템은 N 번의 기능 확장을 통해 개발
   - 대부분의 요구사항이 정의되어 있지만, 시간이 지남에 따라 개선 여지가 있는 경우에 유용함
   - 개발 초기의 외부 인터페이스 H/W S/W에 대한 리스크를 줄이는데 유용하게 적용가능 함
6. 나선형 Spiral 모델
   - 기술적 리스크를 줄이기 위해 반복적, 점증적으로 SW를 개발하는 모델
   - 목적: 위험의 최소화, 대규모 위험 부담이 큰 시스템 개발에 적합함
   - 폭포수 모델과 프로토타이핑 모델의 장점에 위험 분석을 추가한 모델
   - 많은 프로토타입이 개발되고 각 프로토타입은 요구사항의 실현 가능성/수행 가능성을 증명함
7. 사례 : 기업의 SW 생명주기 모델 선정을 위한 프로젝트 리스크 및 불확실성 평가
   - 프로젝트의 요구사항이 프로젝트를 수행하면서 점점 명확해지는 경우
     - 진화 모델 또는 증가 모델이 적합함
   - 프로젝트의 복잡성이 높은 경우
     - V모델이나 VP모델을 적용하기 어려움

#### 소프트웨어 개발 방법론

정의

- SW 개발 시 계획, 분석, 설계 및 구축의 각 단계에서 정형화된 방법과 절차, 도구 등이 공학적인 기법으로 체계적으로 정리되어 표준화된 이론

특징

- 소프트웨어 개발의 각 단계에서 수행활동, 산출물, 검증 절차, 완료 기준이 정의 됨
- 개발의 각 단계 별 정형화된 방법, 절차, 지원 도구가 정의 됨

필요성

	- 개발 경험의 축적 및 재활용을 통한 개발 생산성 향상
	- 효과적인 프로젝트 관리
	- 공식 절차와 산출물을 제시하고 표준용어를 통일하여 의사소통 수단 제공
	- 각 단계 별 검증과 승인된 종료를 통해 일정 수준의 품질 보증

주요 개발 방법론의 종류

1. 구조적 방법론 : 1970 프로세스 중심
   - 정의 : 정형화된 분석 절차에 따라 사용자 요구 사항을 파악하는 방법론
   - 특징 : 프로세스 중심, 분할과 정복의 원칙, 낮은 재사용성과 유지보수성
   - 기본원리 : 추상화, 구조화, 단계적 상세화, 모듈화
   - 주요 산출물 : 데이터 흐름도, 구조도, 프로그램 사양서
   - 주요 언어 : COBOL, C, VB, PASCAL
2. 정보공학 방법론 : 1980 데이터 중심
   - 정의 : 기업 정보시스템에 공학적 기법을 적용하여 시스템의 계획, 분석, 설계 및 구축을 하는 데이터 중심의 방법론
   - 특징 : 정보전략계획 ISP 가 필수, 공학적 접근, 유지보수성. 재사용성 낮음
   - 기본원리 : 정보 전략 계획, 업무영역 분석, 업무 시스템 설계, 시스템 구축
   - 주요 산출물 : 도메인 분석서, ERD, 테이블 정의서/목록, 기능차트, 프로그램 사양서
   - 주요 언어 : COBOL, C, VB, PASCAL
3. 객체지향 방법론 : 1990 모듈화
   - 정의 : 객체지향 기법이 적용된 객체, 클래스 간의 관계를 식별하여 SW를 개발하는 방법론
   - 특징
     - 캡슐화 : 서로 관련성이 많은 데이터와 이를 참조하는 함수들을 하나로 묶어 처리 가능한 특성
     - 추상화 : 복잡한 현실세계를 간단한 객체로 추상화 시킴
     - 다형성
       - 동일 인터페이스에 대해 서로 다른 처리 방식으로 구현 가능한 특성
       - 오버로딩 Overloading : 하나의 이름으로 여러개의 메서드를 만들 수 있는 기법
       - 오버라이딩 Overriding : 상위 클래스에 있는 동일한 메서드를 재정의하는 기법
     - 정보은닉
       - 객체의 상세한 내용을 객체 외부에 숨기고 메시지만으로 객체와 상호 작용하는 성질
       - 클래스 선언 시 "public"은 외부 사용가능, "private"은 외부 사용 불가
     - 상속 : 부모 클래스의 속성을 자식 클래스에서 자동으로 부여받아 사용 가능한 특성, 클래스의 확장이 용이
   - 기본원리 
     - 단일 책임의 원칙 : 하나의 객체는 하나의 기능만 수행
     - 개발 폐쇄 원칙 : 확장에는 개방되어 있고, 수정에는 폐쇄되어 있음
     - 리스코프 치환의 원칙 : 하위 클래스/타입들은 상위 타입들이 사용되는 곳에 대체 가능
     - 인터페이스 분리의 원칙 : 하나의 인터페이스보다 여러개의 구체적 인터페이스 지향
     - 의존성 뒤집기 원칙 : 자주 변경되는 구체 클래스보다 추상화된 클래스에 의존
   - 주요 산출물 : 프로젝트 계획서, 다이어그램
   - 주요 언어 :  C++, JAVA, VB
   - 객체지향 Object Oriented의 개요
     - 정의 : 실 세계의 개치 Entity를 속성 Attribute과 메소드 Methode가 결합된 형태의 객체 Object로 표현하는 개념, 구현대상을 하나의 객체로 보고, 그 객체를 객체와 객체들 간의 관계로 모델링하는 방법
     - 등장배경 : 소프트웨어 위기 해결을 위한 대안 필요성 증대. 컴퓨팅 환경에 대한 보다 많은 기능 Functionality, 단순성, 사용 편의성에 다한 사용자 요구 증대
4. CBD 방법론 : 2000 재사용성 증대
   - 정의 :재사용이 가능한 컴포넌트의 개발 또는 사용 컴포넌트들을 조합하여 SW를 개발하는 방법론
   - 특징
     - 객체지향 방법론의 진화
     - 인터페이스 중시
     - 컴포넌트 재사용 지향 (블랙박스 재사용)
     - 테스트 환경 부족 및 컴포넌트 평가 미흡
   - 주요 산출물 : 비즈니스 프로세스, 개념도, 다이어그램
   - 주요 언어 : 원칙적으로 개발언어에 무관함, JAVA, .NET

#### Agile : 2000 적시성 중심

정의 

- 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 방법론

등장배경 

- SW개발 환경 변화

  - 다양해진 사용자 요구

  - 짧아진 정보시스템의 수명 주기

- 기존 방법론의 한계

  - 문서 위주, 절차 중심
  - 시장 변화 대응 한계

- 애자일 개발 방법론 대두
  - 정보시스템의 time-to-market
  - Products의 적시 배포 Release

특징

- 가변적인 요구에 대응이 용이함
- 프로세스 중심이라기 보다 사람 중심의 방법론 : 절차 보다는 개개인의 상호작용이 더욱 중요
- 고객의 적극적인 참여가 필요
- 대규모 조직보다는 중소형, 아키텍처 설계, 프로토타이핑에 적합함

애자일 방법론의 종류

- XP eXtreme Programming
  - 정의 : 개발자, 고객 간의 의사소통을 개선하고 즉각적인 피드백에 의해 단순하게 코딩하여 SW의 개발 생산성을 높이기 위한 방법론 (반복적 개발 방법론의 일종)
  - 실천방법
    - 환경 : 고객이 개발 현장에 상주
  - 관리
    - 계획 게임 : 프로젝트 계획을 비즈니스와 기술 측면 고려하여 수립
    - 작은 릴리즈 : 실행 가능한 모듈을 가능한 빨리 배포
    - 메타포 : 시스템에 대한 전체 모습을 이해하기 쉬운 그림, 스토리로 표현
  - 개발
    - 단순한 설계
    - 테스트 기반 개발 TDD : 코드 작성 전 테스트부터 수행하고 자동화
    - 리팩토링 : 기존 코드의 복잡성, 중복성 제거
    - 코딩 표준
    - 짝 프로그래밍 : 두명의 개발자가 한 컴퓨터에 앉아 공동 개발 진행
    - 코드 공유 : 모든 개발자가 소스코드에 대한 공동 책임 보유
    - 지속적인 통합 : 작업 완료 시까지 통합 작업 수행
  - 개발절차
    - 유저스토리 : 기능단위의 요구사항, 의사소통의 도구
    - 스파이크 : 기술 문제의 위험을 감소시키기 위한 간단한 프로그램
    - 릴리즈 계획 : 전체 프로젝트에 대한 배포 계획, 하나의 반복을 1~3주로 나누어 반복들을 균일하게 유지
    - 승인 테스트 : 릴리즈 전 인수 테스트, 고객이 직접 수행
    - 작은 릴리즈 : 소규모로 빈번하게 배포
  - 추구가치
    - 용기 : 고객의 요구사항 변화에 능동적인 대처
    - 단순성 : 불필요한 복잡성을 제거하여 단순하고 명확하게 유지
    - 의사소통 : 고객, 개발자, 관리자들 간의 의사소통을 통해 문제를 해결하고 팀워크 강화
    - 피드백 : 빠른 피드백 추구
    - 존중 : 팀원 간의 상호 존중
- SCRUM
  - 정의
    - 일본에서 개발 환경을 최대한 이용하고 조직의 고정비를 줄이며 반복적인 프로토타입을 기반으로 SW을 개발하는 방법론
  - 프로세스
    - 제품 백로그 정의 : 실제 구현할 기능 목록의 나열, 기능에 대한 우선순위 정의
    - 스프린트 계획 수립 : 1~4주 단위의 반복 개발 기간 Iteration 수리
    - 일일 스크럼 수행  : 매일 15분 내외의 진행 상황을 공유하는 회의 (한 일, 할 일, 문제점)
    - 스프린트 리뷰 : 스프린트 목표 달성 요부를 작업 진행과 결과물을 통해 확인하는 회고 미팅
  - 스크럼 역할자 유형
    - 제품 책임자 : 고객 담당자, 새로운 항목을 추가하는 일을 관리
    - 스크럼 마스터 : 팀의 업무를 방해하는 요소를 제거. 원칙과 가치를 지키면서 팀이 개발을 진행할 수 있도록 지원
    - 스크럼 팀 : 5~9명으로 구성된 개발 팀. 사용자 스토리를 사용하여 개발할 기능을 도출
  - 산출물 유형
    - 제품 백로그 : 개발할 제품에 대한 요구사항 목록 전체. 우선순위에 따른 Sprint Point 부여
    - 스프린트 백로그 : 특정 Sprint 기간 동안에 수행되어야 할 기능 목록, 각 과업의 크기는 시간 단위로 추정
    - 소멸 차트 : 개발을 완료하기까지 남은 작업량을 보여주는 그래프. 각 Iteration 변로 남은 작업량을 스토리 포인트로 표현
  - 미팅유형
    - 스프린트 계획 : 각 스프린트에 대한 목표를 설정
    - 일일 스크럼 : 25분 미팅
    - 스프린트 리뷰 : 스프린트 목표 달성 여부 확인, 결과 공유, 피드백 제공, 회고 진행

### 4.1.3. 소프트웨어 재사용

#### 소프트웨어 재사용의 개념

정의

- 기존의 소프트웨어 또는 소프트웨어 지식을 활용하여 새로운 소프트웨어를 구축하는 일

SW 재사용 배경 

- SW위기로 품질 및 생산성 저하
- SW 개발 자동화 기술 발달로 CASE 도구 사용 확대
- 개발 표준화 준수 및 품질 확보 필요

SW 재사용 효과

- TCO 절감
- 고품질 보장
- 개발에 대한 정보 및 산출물 공유
- 시스템 구조와 좋은 시스템 구축 방법에 대한 교육적 효과

#### 3R

정의

- 레포지토리 Repository 를 기반으로 역공학 Reverse Engineering, 재공학 Reengineering, 재사용 Reuse을 통해 소프트웨어 생산성을 극대화하는 기법
  - 역공학 : 구현된 SW를 분석하여 설계 단계에서의 요구사항을 역으로 분석
  - 재공학 : 역공학으로 재구조화된 SW를 기반으로 정보를 추출하고 이를 다시 구현함으로써 재사용성을 확보하는 SW 부품으로 만들어 내는 작업
  - 재사용 : 재공학을 통해 현실화된 SW를 실제로 사용

## 4.2. 자료구조와 알고리즘

1. 자료 구조
2. 알고리즘

### 4.2.1. 자료 구조

#### 자료 구조의 개요

정의

- 자료를 컴퓨터의 기억장치 내에 저장하는 방법

분류

- 선형 구조
  - 원시코드로 부터 정보를 추출하여 물리적 설계 저장소에 저장
  - 배열, 리스트(선형리스트, 연결리스트), 스택, 큐
- 비선형 구조
  - 한 자료 뒤에 여러 개의 자료들이 존재
  - 트리, 그래프
    - 트리
      - 목적 : 빠른 자료 탐색
      - 루트 노드 : 최상의 노드
      - 가지 노드 : 상위 노드를 가지는 하위 노드
      - 차수, 레벨, 높이
      - 활용 분야 : 탐색이나 정렬, 문법의 파싱, 허프만 코드, 게임
    - 그래프
      - 정점 Vertex, Node과 간선 Edge로 이루어진 비선형 자료 구조
      - 차수 : 하나의 정점에 닿아 있는 간선의 수
      - 활용 분야 : 전기 회로 분석, 최단 거리 검색, 인공지능, 네트워크 라우팅

자료 구조의 선택 기준 : 자료의 특성과 사용 용도에 맞는 자료 구조 선택 필요

### 4.2.2. 알고리즘

#### 알고리즘 개요 및 분석 기준

정의

- 주어진 문제를 해결하기 위한 일련의 처리 절차를 단계적으로 기술한 것으로 문제 해결 방법을 추상화하여 단계적 절차를 논리적으로 기술한 명세서
- SW 개발의 품질 확보에 중요한 역할을 수행

목적

- 모듈성
  - 소프트웨어 설계에서 모듈성을 얻기 위해, Black Box 개발에 초점을 둠
  - 사용자는 개발자가 규정한 공개 인터페이스를 통해서만 접근가능
  - 개발자는 사용자가 알 필요 있는 부분만 공개하고 나머지 상세부분은 감춤
- 단순성
  - 단순한 방법이 더 좋은 결과를 도출
- 가독성
  - 그 자체로 설명되어지는 코드를 만드는 것
  - 헤더 파일을 이용해 자료구조와 알고리즘에 대한 공개 인터페이스 정의하고 공개하여 가독성을 높임
- 일관성
  - 규칙을 바탕으로 만들어진 것을 이해하면 이후에는 보기만 해도 이해 가능
  - 일관성은 가독성과 단순성 증진

알고리즘 성능 분석

- SW 실행에 필요한 공간 측면에서 분석하는 공간 복잡도와 실행에 소요되는 시간 측면에서 분석하는 시간 복잡도를 추정하여 알고리즘 성능 평가를 수행
  - 시간 복잡도 : 컴파일 시간 + 실행 시간
  - 공간 복잡도 : 고정 공간량 + 가변 공간량

빅-오 Big O 표기법

- 알고리즘의 시간 복잡도를 나타내기 위한 표기법
- 가장 작은 값의 시간 복잡도를 가지는 알고리즘을 선택

#### 정렬 알고리즘

개요

- 정렬 장소에 따라 내부 정렬과 외부 정렬로 분류
- 사용하는 시스템의 특성, 데이터의 양과 상태, 정렬에 필요한 기억 공간 및 실행 시간 등의 조건을 고려하여 선택 필요

정렬 알고리즘 종류

- 내부 정렬 : 소량의 데이터에 대해 주기억 장치에 올려서 정렬하는 방식
- 외부 정렬 : 대량의 데이터에 대해 보조 기억 장치에서 정렬하는 방식

주요 정렬 알고리즘 설명

- 버블 정렬 : 여러 개의 자료 중에서 서로 이웃하는 값을 두 개씩 비교하여 순서를 결정하는 정렬 방법
- 삽입 정렬 : 첫번째 값은 정렬된 것으로 보고 두번째 값부터 순서에 맞는 위치에 삽입시키는 정렬 방법
- 힙 정렬 : 완전이진트리에 있는 Node 중에서 값이 가장 큰 Node나 가장 작은 Node를 찾기 위한 정렬 방법
- 퀵 정렬 : Pivot을 기준으로 작은 값을 왼쪽, 큰 값을 오른쪽에 위치시키는 분할과 정복에 기반한 알고리즘

#### 탐색 알고리즘

개요

- 그래프 자료 구조를 이용하여 가장 가까운 거리 등을 탐색하기 위한 알고리즘

탐색 알고리즘의 방법

- 깊이 우선 탐색 DFS, Depth First Search
  - 시작 정점의 한 방향으로 갈 수 있는 경로가 있는데까지 깊이 탐색하다가 더이상 갈 곳이 없으면 가장 가까운 갈림길로 돌아와 이전에 가지 않았던 다른 방향으로 재탐색을 진행하는 방법 , 스택 기반 알고리즘
- 너비 우선 탐색 BFS, Breadth Fist Search
  - 시작 정점으로 부터 가까운 정점을 먼저 방문하고 멀리 떨어진 정점을 나중에 방문하는 방법, 큐 기반 알고리즘
- 이진 탐색 알고리즘
  - 이진 트리의 정렬된 데이터 집합에서 탐색 범위를 절반씩 줄여 나가면서 수행하는 방식
  - 분할과 정복 기반, 이미 정렬되어 있는 데이터 집합을 사용, 고속 탐색 가능

## 4.4. 소프트웨어 분석

1. 요구사항 분석
2. 요구사항 분석 주요 방법론
3. 요구사항 명세

### 4.4.1. 요구사항 분석

#### 요구사항 분석의 개요

고려사항

- 모든 요구사항은 동작 및 측정 가능하도록 정의해야 함
- 설계 단계에서 활용이 가능한 수준으로 상세하게 정의해야 함

#### 요구사항 분석의 필요성 및 효과

요구사항 분석의 필요성

- 산출물간의 연계성
- 요구사항 오류로 인한 재작업
- SW개발 예산 낭비
- 품질 저하 문제

요구사항 분석 활동의 효과

- 의사소통 효율성 제고
  - UML Unified Modeling Language 이용 : 그림 그리기, 도식화

- 체계성 문제 해결
- 소스 코드 재사용

#### 4.4.2. 요구사항 분석 주요 방법론

#### 구조적 분석

정의

- 요구사항 분석으로 논리적 기능에 대한 명세를 구성하는 것을 목표로 하는 방법론

목적

- 개발된 시스템의 목적을 정의하는 것

구조적 분석의 프로세스

- 시스템 문맥도 작성
- 데이터 흐름도 작성
- 데이터 프로세스 명세
- 제어 프로세스 명세
- 데이터 사전 작성 : 데이터 흐름도를 작성하는 과정에서 식별된 데이터들을 정리

#### 객체지향 분석

정의

- 객체 지향 개념에 입각하여 SW를 개발하는 객체 지향 개발 방법론에서 시스템에 대한 요구사항을 분석하는 방법론

특징

- UML을 이용한 모델링
- 객체 개념에 입각하여 확장성과 유지보스성이 용이

객체 지향 분석의 주요 활동

- 요구사항 명세분석 : 유즈케이스 다이어그램
  - 기능 요구사항 들을 분석하여 유즈케이스 모델로 변환
- 객체 및 행위 분석 : 정제된 유즈케이스 다이어그램

### 4.4.3. 요구사항 명세

정의

- 요구사항을 정형화하고 표준화된 템플릿에 의해 문서화 하는 방법

필요성

- 사용자 입장
  - 원할한 의사소통의 도구
  - 계약서로 활용
  - 최종 시스템에 대한 검증 기준
- 개발자 입장
  - 개발할 시스템에 대한 이해
  - 분석, 설계, 개발의 기준
  - 시스템에 대한 점검 기준

요구 명세의 원리

- 완전성
- 명확성 
- 일관성 : 서로 상반된 요구나 불일치, 중복된 요구가 없어야 한다는 원리
- 추적 가능성 : 요구 명세서를 통해 설계 내용, 적용 기법, 변경 사항 등을 모두 추적할 수 있어야 한다는 원리
- 변경 용이성
- 검증 가능성

# 4.5. 소프트웨어 설계

1. 설계 원리와 평가 기준
   1. 계의 개요
   2. 설계원리
   3. 설계 평가 기준 - 응집도, 결합도
2. 소프트웨어 아키텍처 설계
   1. 개념 및 구성요소
   2. 소프트웨어 아키텍처 스타일
3. 객체지향 설계
   1. 개념과 원리
   2. 모델링과 UML
   3. 디자인 패턴
4. UI/UX 설계

### 4.5.1. 설계 원리와 평가 기준

#### 설계의 개요

정의

- 어떻게 구축할 것인가를 결정하는 단계
- 시스템을 구축하기 위해 필요한 구체적인 설계서를 작성하고 해당 설계를 평가할 수 있는 정량적인 기준을 명시하는 SW개발 프로세스

설계의 단계 별 종류

- 설계는 요구 분석 명세서와 설계 원리, 제약 조건에 따라 상위 설계와 하위 설계로 구분됨
- 상위 설계 : 시스템 구축을 위한 전체적인 뼈대

#### 설계 원리

설계 원리 설명

- 분할과 정복 (구조화)

  - 규모가 큰 소프트웨어 하나를 개발할 때 여러개의 하위 시스템으로 나누고 하나씩 개발함

  - 가장 세분화된 작은 시스템을 개발하고 하나씩 위로 올라가면서 시스템을 완성시키는 원리

  - 모듈로 나누면 모듈끼리 서로 통신하는 방법이 필요하므로 복잡도가 증가할 수 있음

    > 복잡도로 인한 증가 비용과 처리의 용이성을 고려하여 결정해야 함
    >
    > 쪼개는 과정 : 분할
    >
    > 합치는 과정 : 정복

- 단계적 분해

  - 기능을 점점 작은 단위로 나누어 점차적으로 구체화하는 방법
  - 높은 추상화 단계에서 낮은 추상화 단계로 가는 하향식 설계로 각 기능을 분해

- 정보 은닉

  - 각 모듈의 내부 내용을 감추고 (추상화) 인터페이스를 통해서만 메시지를 전달할 수 있도록 하는 원리
  - 모듈 사이의 독립성을 유지시켜 주고 유지 보수성을 용이하게 하는 원리

- 추상화

  - 주어진 문제에서 현재의 관심사에 초점을 맞추기 위해 특정한 목적과 관련된 필수 정보만 추출하여 강조하고 관련이 없는 세부 사항을 생략하여 본질적인 문제에 집중할 수 있도록 하는 원리

- 모듈화

  - 하나 또는 몇 개의 놀리적인 기능을 수행하기 위한 명령어들의 집합
  - 모듈은 시스템의 유지 보수와 수정을 용이하게 해줌
  - 모듈화 목표 : 높은 응집도, 낮은 결합도

#### 설계 평가 기준 - 응집도, 결합도

개요

- 모듈 간의 독립성을 최대화할 수 있어 설계의 품질을 높이기 위해 좋은 설계가 이루어졌는지 평가 하기 위한 요소가 필요함

응집도의 종류와 정도

- 기능적 응집도 : 응집도 강함
- 순차적 응집도
- 통합적 응집도
- 절차적 응집도
- 시간적 응집도
- 논리적 응집도
- 우연적 응집도

결합도 Coupling

- 모듈 사이의 상호 연관성의 복잡도
- 서로 의존성이 높을수록 결합도가 높아짐

결합도의 종류와 정도

- 자료 결합도 : 결합도 약함 : 매개 변수나 인수로 모듈 간 데이터를 전달
- 스탬프 결합도
- 제어 결합도
- 외부 결합도
- 공통 결합도
- 내부 결합도

### 4.5.2. 소프트웨어 아키텍처 설계

정의

- 소프트웨어 개발에 직간접적으로 영향을 미치고 복잡도를 높이는 다양한 요소들을 체계적으로 다루기 위한 개발 대상 소프트웨어의 청사진
- 소프트웨어 컴포넌트 및 외부로 나타나는 컴포넌트의 특성, 관계들로 구성되는 시스템의 구조

소프트웨어 아키텍처의 구성요소

#### 소프트웨어 아키텍처 스타일

정의

- 원하는 소프트웨어를 생산하기 위한 소프트웨어 아키텍처의 구조, 규칙, 요소, 기법

유형

- 기능의 분할과 배치
  - 데이터 중심형 모델
    - 리포지토리 모델
    - 장점 : 데이터가 리포지토리에 모여 있어서 데이터의 일관성있는 관리 가능
    - 단점 : 리포지토리의 병목현상
  - 클라이언트-서버 모델
    - 데이터와 처리 기능을 클라이언트와 서버에 분할하여 사용
    - 분산 아키텍처 유형에 적합
    - 구성 : 서버(서비스 제공), 클라이언트 (서비스 요청), 서비스
  - 계층 모델
    - 기능을 몇 개의 계층으로 나누어 배치
    - 상위 계층은 클라이언트, 하위 계층은 서버 역할
    - 프레젠테이션 계층, 비즈니스 로직 계층, 데이터 계층
  - MVC Model-View-Controller 모델
    - 중앙 데이터 구조
    - 여러 개의 뷰 서브시스템을 필요로 하는 상호작용 시스템에 적합
    - 구성 : 모델 - 모든 데이터 상태와 로직을 처리하고, 호출에만 응답
- 제어 관계

### 4.5.3. 객체지향 설계

#### 개념과 원리

객체 지향 설계의 원리

- 단일 책임의 원칙 SRP, Single Response Principle
  - 객체는 하나의 책임만을 맡아야 함
  - 개 이상의 책임을 가지면, 온전한 책임을 다할 수 있도록 분리
  - 낮은 결합도, 높은 응집도 추구
- 개방 폐쇄 원칙 OCP, Open Closed Principle
  - 모듈의 행위는 확장, 추가되어야 하지만 수정에는 닫혀있어야 함
  - 모듈의 기존 소스 코드는 수정되어서는 안 됨
- 리스코프 치환의 원칙 LSP, Liskov Substitution Principle
  - 하위 클래스 및 타입들은 상위 타입들이 사용되는 곳에 대체될 수 있어야 한다는 설계 원칙
- 인터페이스 분리의 원칙 ISP, Interface Segregation Principle
  - 하나의 일반적인 인터페이스보다는 구체적인 여러 개의 인터페이스가 나음
  - 클라이언트는 자신의 사용하지 않는 메소드에 의존 관계를 맺으면 안 됨

- 의존성 뒤집기의 원칙 DIP, Dependency Inversion Principle
  - 추상화된 것에 의존하게 만들고, 구체클래스에 의존하도록 만들지 않도록 한다는 원칙
  - 자주 변경되는 구체 클래스 concrete class 에 의존하지 않아야 함
  - 구체적인 것이 추상화된 것에 의존해야 함

#### 모델링과 UML

정의

- 구축 대상 시스템의 성능 또는 동작 과정 분석을 위하여 이를 간단히 도식화하거나 그 시스템의 특징을 수학적으로 표현하는 과정

#### 디자인 패턴

정의

- 소프트웨어 디자인 설계시 통속적으로 발생하는 문제에 대한 일반적으로 재사용이 가능한 해결책 혹은 경험적인 솔루션 또는 견본
- 로그래머가 구현해야 하는 모범 사례들을 공식화하여 보여주는 관계들

디자인 패턴의 목적에 따른 분류 설명

- 생성패턴
  - 객체의 생성 방식을 결정하는 패턴
  - 시스템이 어떤 구체 클래스를 사용하는지에 대한 정보를 캡슐화
- 구조패턴
- 행위패턴

### 4.5.4. UI/UX 설계

UI User Interface

설계 시 고려사항

- 일관성 필요
- 사용자 중심 설계 필요
- 피드백
- 파괴적인 행동에 대한 확인

UX User eXperience 사용자 경험

- 사용자의 환경을 개선하려는 설계자의 사고와 행동
- 사용자가 어떤 시스템, 서비스를 통해 목적을 이루려 할 때 느끼는 경험, 감정, 지각, 태도, 반응의 종합적인 경험

## 4.6. 소프트웨어 구현 및 테스팅

1. 프로그래밍 언어
   1. 개요
   2. 주요 개발 언어
   3. 소프트웨어 개발 프레임워크
   4. 통합개발환경 IDE
2. 테스팅
   1. 개념 및 프로세스
   2. 테스트 케이스 설계방법
   3. 유형 및 기법
3. 리팩토링

### 4.6.1. 프로그래밍 언어

#### 개요

정의

- 프로그램을 작성하는데 쓰이는 언어
- 고급언어 : 프로그래밍 언어 C++, JAVA
- 저급언어 : 기계어, 어셈블리어 > 사람이 기계어로 복잡한 프로그램을 개발하는 것은 불가능 > 프로그래밍 언어 필요

프로그래밍 언어 작동 매커니즘

- 기계가 이해할 수 있는 언어로 번역 > 컴파일러, 인터프리터 등의 번역기 필요

컴파일러언어와 인터프리터 언어

- 컴파일러 Compiler 언어
  - 한 언어를 동등한 의미를 갖는 다른 언어로 바꾸는 것
  - 객체 모듈 Object Module을 만들고, 이 모듈을 링크, 로드하여 실행
  - 장점 : 번역된 목전 코드 저장 가능, 컴파일 후 그대로 재실행이 가능 빠름
  - 단점 : 기계어로 변환하는데 많은 시간이 소요, 메모리 낭비가 발생할 수 있음
- 인터프리터 Interpreter 언어
  - 중간과정 없이 원시 프로그램을 직접 저급 언어로 바꾸면서 동시에 실행
  - 장점 : 대화식 프로그램에 좋다, 기억 장소가 많이 필요하지 않다.
  - 단점 : 재실행 시 매번 디코딩하므로 시간이 많이 소요됨

#### 주요 개발 언어

프로그래밍 언어의 발전 과정

#### 소프트웨어 개발 프레임워크

정의

- 효율적인 정보시스템 개발을 위한 코드 라이브러리, 인터페이스 규약, 설정 정보 등의 집합
- 소프트웨어 구성에 필요한 기본 뼈대

소프트웨어 개발 프레임워크의 종류

- 스프링 프레임워크
  - 자바 플랫폼을 위한 오픈소스 어플리케이션 프레임워크
  - 안전성과 유연성이 입증되어 공공산업, 전자정부 표준개발 프레임워크의 핵심 근간으로 활용

### 4.6.2. 테스팅

#### 개념 및 프로세스

정의

- 응용프로그램 또는 시스템의 동작과 성능, 안정성이 사용자가 요구하는 수준을 만족하는지 확인하기 위해 결함을 발견하는 활동

테스트 프로세스

- 테스트 계획과 통제
- 테스트 분석과 설계
- 테스트 구현과 실행
- 완료 조건의 평가 및 리포팅
- 테스트 마감

#### 테스트 케이스 설계 방법

테스트 케이스 설계 기법 별 설명

- 명세기반 기법
  - 테스트 대상의 내부구조를 참조하지 않고 테스트 베이시스 문서, 개발자, 테스터와 사용자들의 경험을 분석하여 테스트 조건과 테스트 케이스를 도출하고 선택하는 방법
- 구조기반 기법
  - 소프트웨어 또는 컴포넌트 등의 로직에 대한 테스트를 수행하기 위하여 설계 단계에서 요구 사항을 확인하여 테스트 하는 유형
  - 개발자들이 자기가 구현한 소스 코드를 테스트 할 때 쓰는 기법
  - 화이트 박스 테스트

### 4.6.3. 리팩토링

정의

- 외부에서 보는 프로그램의 동작은 변경하지 않고 프로그램 내부 구조를 개선하는 활동
- 복잡한 소스, 코드 스멜 등을 개선하여 확장성을 높이고 효율성을 향상시키는 활동

리팩토링 기법

- 메소드 정리
- 객체 간 기능 이동
- 이름

코드 스멜의 개념

- 읽기 어렵거나 중복된 로직을 가진 프로그램처럼 개발자가 이해하거나 유지보수하기 어려워 리팩토링의 대상이 되는 코드
- 리팩토링을 통해 Red Code > Green Code > Clean Code로 변경됨

## 4.7. 소프트웨어 관리

1. 요구사항 관리
2. 형상관리
3. 유지관리
4. 품질관리

### 4.7.1. 요구사항 관리

#### 개념 및 프로세스

요구사항 공학의 개요

- Requirements Engineering 은 크게 요구사항 개발과 요구사항 관리로 구분
- 요구사항 개발 : 무엇을 할 것인가를 정의
- 요구사항 관리 : 정의된 요구사항이 제대로 반영되어 진행되는지를 확인, 최초 요구사항 변경에 대한 지속적인 관리를 수행

요구사항 관리 원칙

- 요구사항 변경관리 위원회 CCB, Change Control Board 운영을 통한 요구 변경의 영향 분석 및 변경 단계 별 베이스라인 (Baseline) 설정

#### 요구사항 변경 및 추적관리

개요

- 요구사항 베이스라인을 기반으로 모든 변경을 공식적으로 통제하기 위한 기법

### 4.7.2. 형상관리

#### 개념 및 활동

형상관리 활동의 정의

- 소프트웨어 개발 과정에서 만들어지는 각종 산출물들을 체계적으로 관리하고자 하는 관리 기법
- SW 구성 요소들의 변경 이력에 관련된 행동들을 관리하는 활동

주요 형상관리 도구 설명

- 서브버전 Subversion
- 분상형 저장소 Git

### 4.7.3. 유지관리

### 4.7.4. 품질관리

개념

- 소프트웨어 생명주기 동안에 이루어지는 모든 활동과 그 결과로 생산되는 산출물에 대한 품질을 통제, 보증하기 위한 활동

